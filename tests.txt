/*
 * Notice that the list of included headers has
 * expanded a little. As before, you are not allowed
 * to add to this.
 */
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <unordered_set>
#include <unordered_map>
#include <set>
#include <array>
#include <list>
#include <forward_list>
#include <deque>
#include <map>
#include <cstddef>
#include <string>
#include <utility>
#include <algorithm>
#include <limits>
#include <optional>
#include <exception>
#include <stdexcept>

#include "directed_graph.hpp"




/*
 * Computes whether the input is a Directed Acyclic Graph (DAG).
 * A digraph is a DAG if there is no vertex that has a cycle.
 * A cycle is a non-empty set of [out-]edges that starts at one 
 * vertex, and returns to it.
 */
template <typename vertex>
bool is_dag(const directed_graph<vertex> & d) {
	std::list<vertex> list = topological_sort(d);
    if(d.num_vertices() ==0) {
    return true;
  }
  if(list.empty()) {
      return false;
  }
  return true; 
  

  


	// list<vertex> s = {};
	// while(!s.empthy()) {
	// v = s.remove
	// topo_order.append(v)
	// for (u.contains(v)) {
	// 	remove(v,u) from graph 
	// 	if(u has no edges) {
	// 		add u to s
	// 	}
	// }
	// }
  return false;
}

/*
 * Computes a topological ordering of the vertices.
 * For every vertex u in the order, and any of its
 * neighbours v, v appears later in the order than u.
 */
template <typename vertex>
std::list<vertex> topological_sort(const directed_graph<vertex> & d) {
  std::list<vertex> topo_order; 
  std::queue<vertex> edges_out; 
  directed_graph<vertex> g = d; 
  
  for(auto a:d) {
    if(d.in_degree(a)==0) {
      edges_out.push(a);
    }
   }
   
   while(!edges_out.empty()) {
     vertex v = edges_out.front();
     edges_out.pop(); 
     topo_order.push_back(v);
     
     for(auto a = d.nbegin(v); a!=d.nend(v); a++) {
         g.remove_edge(v, *a);
         if(g.in_degree(*a)==0) {
             edges_out.push(*a);
         }
     }
   }
   if(g.num_edges() == 0) {
       return topo_order;
   }
   return std::list<vertex>(); 
}
  
  

  
/*
 * Given a DAG, computes whether there is a Hamiltonian path.
 * a Hamiltonian path is a path that visits every vertex
 * exactly once.
 */
template <typename vertex>
bool is_hamiltonian_dag(const directed_graph<vertex> & d) {
  // std::unordered_set<vertex> vertices;
  //whether it is not a hamiltonian and loop through every adjacency 
  //insert each vertex using iterator 
  std::list<vertex> list = topological_sort(d);
  std::vector<vertex> vertices; 
  
    for(auto a= list.begin(); a!=list.end(); a++) {
    vertices.push_back(*a);
  }
  
  
  if(!is_dag(d))  {
    return false;
  }
  
   else if(d.num_vertices()<=1) {
    return true;
  } 
  
  else if(d.num_edges()==0 && d.num_vertices()>0) {
  return false; }
  
    else if(list.size()==0) {
    return false;
  }
    
   else{
    for(int i=0; i<vertices.size();i++) {
    
      if(!d.adjacent(vertices[i],vertices[i+1]) && list.size()==d.num_vertices()) {
        return false;
      }     
      return true;
    }
  }
}

/*
 * Computes the weakly connected components of the graph.
 * A [weak] component is the smallest subset of the vertices
 * such that the in and out neighbourhood of each vertex in
 * the set is also contained in the set.
 */
template <typename vertex>
std::vector<std::vector<vertex>> components(const directed_graph<vertex> & d) {
  return std::vector<std::vector<vertex>>();
}

/*
 * Computes the strongly connected components of the graph.
 * A strongly connected component is a subset of the vertices
 * such that for every pair u, v of vertices in the subset,
 * v is reachable from u and u is reachable from v.
 */

template <typename vertex>
std::vector<std::vector<vertex>> strongly_connected_components(const directed_graph<vertex> & d) {
  return std::vector<std::vector<vertex>>();
}

/*
 * Computes the shortest distance from u to every other vertex
 * in the graph d. The shortest distance is the smallest number
 * of edges in any path from u to the other vertex.
 * If there is no path from u to a vertex, set the distance to
 * be the number of vertices in d plus 1.
 */
template <typename vertex>
std::unordered_map<vertex, std::size_t> shortest_distances(const directed_graph<vertex> & d, const vertex & u) {
  
 return std::unordered_map<vertex, std::size_t>();
}

